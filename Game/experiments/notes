// int row_count    = 0;
// int column_count = 0;

// Populate the vertex array, with one quad per tile
// std::vector< std::vector<int> >::iterator row;
// std::vector<int>::iterator col;
// for (row = map.begin(); row != map.end(); row++) {
//   for (col = row->begin(); col != row->end(); col++) {
//     // get the current tile number
//     int tileNumber = map[row_count] * width];
//
//     // find its position in the tileset texture
//     int tu = tileNumber % (this->tileset.getSize().x / tileSize.x);
//     int tv = tileNumber / (this->tileset.getSize().x / tileSize.x);
//
//     // Get a pointer to the current tile's quad
//     sf::Vertex* quad = &vertices[(i + j * width) * 4];
//
//     // define the current tile's four corners
//     quad[0].position = sf::Vector2f(i * tileSize.x, j * tileSize.y);
//     quad[1].position = sf::Vector2f((i + 1) * tileSize.x, j * tileSize.y);
//     quad[2].position = sf::Vector2f((i + 1) * tileSize.x,
//                                    (j + 1) * tileSize.y);
//     quad[3].position = sf::Vector2f(i * tileSize.x, (j + 1) * tileSize.y);
//
//     // define the current tile's four texture coordinates
//     quad[0].texCoords = sf::Vector2f(tu * tileSize.x, tv * tileSize.y);
//     quad[1].texCoords = sf::Vector2f((tu + 1) * tileSize.x, tv * tileSize.y);
//     quad[2].texCoords = sf::Vector2f((tu + 1) * tileSize.x,
//                                     (tv + 1) * tileSize.y);
//     quad[3].texCoords = sf::Vector2f(tu * tileSize.x, (tv + 1) * tileSize.y);
//
//     ++column_count;
//   }
//   ++row_count;
// }
